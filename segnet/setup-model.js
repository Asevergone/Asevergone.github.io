#!/usr/bin/env node
// Set up the caffe model prototxt files for a given training data set

var fs = require('fs')
var path = require('path')
var args = require('minimist')(process.argv.slice(2))

var trainingData = args['train'] || (args['data'] + '/' + 'train.txt')
var testData = args['test'] || (args['data'] + '/' + 'val.txt')

var stats = args['label-stats'] || (args['data'] + '/labels/label-stats.csv')

var model = args['model']
var output = args['output']

if (!(output && model && stats && trainingData && testData)) {
    console.log('Usage: setup-model --model segnet|segnet_basic --train /path/to/train.txt --test /path/to/train.txt --label-stats /path/to/labelstats.csv --output /path/to/output/dir')
    console.log('label-stats refers to a the label stats csv generated by skynet-data scripts')
    process.exit(1)
}

var cw = classWeights(stats).map(function (weight) {
  return 'class_weighting: ' + weight
})

var trainTemplate = path.join(__dirname, 'templates', model + '_train.prototxt')
var testTemplate = path.join(__dirname, 'templates', model + '_inference.prototxt')

renderModel(trainTemplate, cw, output)
renderModel(testTemplate, cw, output)

function renderModel (template, classWeights, outputDir) {
  var tmpl = fs.readFileSync(template, 'utf-8')
    .replace(/TRAINING_DATA/g, trainingData)
    .replace(/TEST_DATA/g, testData)
    .replace(/CLASS_COUNT/g, classWeights.length)
    .replace(/(\s+)CLASS_WEIGHTING/g, (_, space) => {
      return classWeights.map(w => space + w).join('')
    })

  var file = path.join(outputDir, path.basename(template))
  fs.writeFileSync(file, tmpl)
}

// compute class weighting according to SegNet paper: http://arxiv.org/abs/1511.00561
function classWeights (stats) {
  var data = fs.readFileSync(stats, 'utf-8').split('\n')
    .slice(1)
    .filter(Boolean)
    .map(x => x.split(',').map(Number))
  var frequencies = data.map(x => x[1] / (x[2] * 65536))
  var sorted = [].concat(frequencies).sort((a, b) => (a - b))
  var n = sorted.length
  var median = n % 2 === 0 ? (sorted[n / 2] + sorted[n / 2 - 1]) / 2 : sorted[n / 2 - 0.5]
  return frequencies.map(x => (median / x))
}
